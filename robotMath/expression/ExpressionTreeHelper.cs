
//
//  This is the helper file for the RealTree example
//  program.  It is an example program for use of the
//  GPPG parser generator.  Copyright (c) K John Gough 2012
//

using System;
using System.Collections.Generic;
using System.Text;
using QUT.Gppg;
using robotMath.Expression.Build;

namespace robotMath.Expression {
    //
    // There are several classes defined here.
    //
    // The parser class is named Parser (the gppg default),
    // and contains a handwritten scanner with class name
    // RealTree.Parser.Lexer.
    //
    // The Parser class is partial, so that most of the 
    // handwritten code may be placed in this file in a
    // second part of the class definition.
    //
    // This file also contains the class hierarchy for the
    // semantic action class RealTree.Node
    //
    // The token enumeration RealTree.Parser.Tokens (also
    // the gppg default) is generated by gppg.
    //
    internal partial class Parser
    {
        private AbstractScanner<Node, LexLocation> scanner;

        internal Dictionary<Node, double> Vars = new Dictionary<Node, double>();

        // 
        // GPPG does not create a default parser constructor
        // Most applications will have a parser type with other
        // fields such as error handlers etc.  Here is a minimal
        // version that just adds the default scanner object.
        // 

        Parser( AbstractScanner<Node, LexLocation> scanner )
        {
            this.scanner = scanner;
        }

        // ==================================================================================
        
        //
        // Now the node factory methods
        //
        public Node MakeBinary( NodeTag tag, Node lhs, Node rhs ) {
            return new Binary( tag, lhs, rhs );
        }

        public Node MakeUnary(NodeTag tag, Node child) {
            return new Unary( tag, child );
        }

        public Node MakeIdLeaf(char n) {
            Leaf retval = new Leaf( n );
            Vars.Add(retval, 0);
            return retval;
        }

        public Node MakeConstLeaf(double v) {
            return new Leaf( v );
        }
    }

    // ==================================================================================
    //  Start of Node Definitions
    // ==================================================================================

    internal enum NodeTag { error, name, literal, plus, minus, mul, div, rem, negate }

    internal abstract class Node {
        public NodeTag Tag { get;  }

        protected Node(NodeTag tag ) { this.Tag = tag; }
        public abstract double Eval( Parser p );
        public abstract string Unparse();
    }

    internal class Leaf : Node {
        char name;
        public double Value { get; set; }

        internal Leaf(char c) : base(NodeTag.name)
        {
            this.name = c;
        }

        internal Leaf(double v) : base(NodeTag.literal)
        {
            this.value = v;
        }

        public int Index { get { return (int)name - (int)'a'; } }
        public double Value { get { return value; } }

        public override double Eval( Parser p ) {
            try {
                if (this.Tag == NodeTag.name)
                    return p.regs[this.Index].Eval( p );
                return this.value;
            }
            finally {
                this.Epilog();
            }
        }

        public override string Unparse() {
            if (Tag == NodeTag.name)
                return this.name.ToString();
            else
                return this.value.ToString();
        }
    }

    internal class Unary : Node {
        Node child;
        internal Unary(NodeTag t, Node c )
            : base( t ) { this.child = c; }

        public override double Eval( Parser p ) {
            try {
                this.Prolog();
                return -this.child.Eval( p );
            }
            finally {
                this.Epilog();
            }
        }

        public override string Unparse() {
            return String.Format( "( - {0})", this.child.Unparse() );
        }
    }

    internal class Binary : Node {
        Node lhs;
        Node rhs;

        internal Binary(NodeTag t, Node l, Node r ) : base( t ) { 
            this.lhs = l; this.rhs = r; 
        }

        public override double Eval( Parser p ) {
            try {
                this.Prolog();
                double lVal = this.lhs.Eval( p );
                double rVal = this.rhs.Eval( p );
                switch (this.Tag) {
                    case NodeTag.div: return lVal / rVal;
                    case NodeTag.minus: return lVal - rVal;
                    case NodeTag.plus: return lVal + rVal;
                    case NodeTag.rem: return lVal % rVal;
                    case NodeTag.mul: return lVal * rVal;
                    default: throw new Exception( "bad tag" );
                }
            }
            finally {
                this.Epilog();
            }
        }

        public override string Unparse() {
            string op = "";
            switch (this.Tag) {
                case NodeTag.div:   op = "/"; break;
                case NodeTag.minus: op = "-"; break;
                case NodeTag.plus:  op = "+"; break;
                case NodeTag.rem:   op = "%"; break;
                case NodeTag.mul:   op = "*"; break;
            }
            return String.Format( "({0} {1} {2})", this.lhs.Unparse(), op, this.rhs.Unparse() );
        }
    }
    // ==================================================================================
}

