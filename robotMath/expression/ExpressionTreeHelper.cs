
//
//  This is the helper file for the RealTree example
//  program.  It is an example program for use of the
//  GPPG parser generator.  Copyright (c) K John Gough 2012
//

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Net.Http.Headers;
using System.Security.Policy;
using System.Text;
using System.Text.RegularExpressions;
using QUT.Gppg;

namespace robotMath.Expression {
    //
    // There are several classes defined here.
    //
    // The parser class is named Parser (the gppg default),
    // and contains a handwritten scanner with class name
    // RealTree.Parser.Lexer.
    //
    // The Parser class is partial, so that most of the 
    // handwritten code may be placed in this file in a
    // second part of the class definition.
    //
    // This file also contains the class hierarchy for the
    // semantic action class RealTree.Node
    //
    // The token enumeration RealTree.Parser.Tokens (also
    // the gppg default) is generated by gppg.
    //
    public partial class Parser
    {
        private AbstractScanner<Object, LexLocation> scanner;
        public static Parser singleton = null;

        internal Dictionary<string, Node> Vars = new Dictionary<string, Node>();
        internal Dictionary<Node, double> VarVals = new Dictionary<Node, double>();
        internal HashSet<Node> VarsWithValues = new HashSet<Node>();
        public Node Root { get; private set; }
        public String LastSym { get; }

        // 
        // GPPG does not create a default parser constructor
        // Most applications will have a parser type with other
        // fields such as error handlers etc.  Here is a minimal
        // version that just adds the default scanner object.
        //

        public Parser( AbstractScanner<Object, LexLocation> scanner ) : base(scanner)
        {
            this.scanner = scanner;
            this.Root = null;
            this.LastSym = "";
        }

        private void RegisterNode(Node node)
        {
            Root = node;
        }

        public void SetVar(string name, double value)
        {
            if (!Vars.ContainsKey(name))
            {
                throw new ArgumentException($"Cannot set value of variable '{name}' to '{value}'. There is no such variable!");
            }
            Node var = Vars[name];
            if (!VarsWithValues.Contains(var))
            {
                VarsWithValues.Add(var);
                VarVals.Add(var, value);
            }
            else
            {
                VarVals.Remove(var);
                VarVals.Add(var, value);
            }
        }

        // ==================================================================================
        // Helper Methods
        // ==================================================================================

        private string GetText()
        {
            return ((Scanner) scanner).yytext;
        }

        public int Precident(NodeTag tag)
        {
            switch (tag)
            {
                case NodeTag.name:      return 4;
                case NodeTag.literal:   return 4;
                case NodeTag.plus:      return 1;
                case NodeTag.minus:     return 1;
                case NodeTag.mul:       return 2;
                case NodeTag.div:       return 2;
                case NodeTag.remainder: return 3;
                case NodeTag.negate:    return 4;
                case NodeTag.exp:       return 3;
                case NodeTag.sin:       return 4;
                case NodeTag.cos:       return 4;
                case NodeTag.tan:       return 4;
                case NodeTag.asin:      return 4;
                case NodeTag.acos:      return 4;
                case NodeTag.atan:      return 4;
                case NodeTag.atan2:     return 4;
                default:
                    throw new Parser.BadOperatorException(Enum.GetName(typeof(NodeTag), tag));
            }
        }

        public int ComparePrecident(string op1, string op2)
        {
            NodeTag firstTag = GetNodeTag(op1);
            NodeTag secondTag = GetNodeTag(op2);
            return Precident(secondTag) - Precident(firstTag);
        }

        // ==================================================================================
        // Factory Methods
        // ==================================================================================

        public NodeTag GetNodeTag(String op)
        {
            return Binary.GetTag(op);
        }

        public Node MakeBinary(NodeTag tag, Node lhs, Node rhs)
        {
            Node retval = new Binary(this, tag, lhs, rhs);
            RegisterNode(retval);
            return retval;
        }

        public Node MakeBinary(string op, Node lhs, Node rhs)
        {
            if (op.Length > 1 && op[0] == '-')
            {
                return MakeUnary("-", MakeBinary(op.Substring(1), lhs, rhs));
            }
            return MakeBinary(Binary.GetTag(op), lhs, rhs);
        }

        public Node m(string op, double l, double r)
        {
            return MakeBinary(op, m(l), m(r));
        }

        public Node m(string op, string l, double r)
        {
            return MakeBinary(op, m(l), m(r));
        }

        public Node m(string op, double l, string r)
        {
            return MakeBinary(op, m(l), m(r));
        }

        public Node m(string op, string l, string r)
        {
            return MakeBinary(op, m(l), m(r));
        }

        public Node m(string op, Node l, double r)
        {
            return MakeBinary(op, l, m(r));
        }

        public Node m(string op, Node l, string r)
        {
            return MakeBinary(op, l, m(r));
        }

        public Node m(string op, double l, Node r)
        {
            return MakeBinary(op, m(l), r);
        }

        public Node m(string op, string l, Node r)
        {
            return MakeBinary(op, m(l), r);
        }

        public Node m(string op, Node l, Node r)
        {
            return MakeBinary(op, l, r);
        }

        public Node MakeUnary(NodeTag tag, Node child) {
            Node retval = new Unary( this, tag, child );
            RegisterNode(retval);
            return retval;
        }

        public Node MakeUnary(string op, Node child)
        {
            if (op.Length > 1 && op[0] == '-')
            {
                return MakeUnary("-", MakeUnary(op.Substring(1), child));
            }
            return MakeUnary(Unary.GetTag(op), child);
        }

        public Node m(string op, double child)
        {
            return MakeUnary(op, m(child));
        }

        public Node m(string op, string child)
        {
            return MakeUnary(op, m(child));
        }

        public Node m(string op, Node child)
        {
            return MakeUnary(op, child);
        }

        public Node MakeLeaf(string n) {
            if (n.Length > 1 && n[0] == '-')
            {
                return MakeUnary("-", MakeLeaf(n.Substring(1)));
            }
            if (Vars.ContainsKey(n))
            {
                return Vars[n];
            }
            Leaf retval = new Leaf( this, n );
            Vars.Add(n, retval);
            RegisterNode(retval);
            return retval;
        }

        public Node MakeLeaf(double v) {
            Node retval = new Leaf( this, v);
            RegisterNode(retval);
            return retval;
        }

        public Node m(string n)
        {
            return MakeLeaf(n);
        }

        public Node m(double v)
        {
            return MakeLeaf(v);
        }

        public Node MakeIdentifierOp(String name, Node lhs, Node rhs)
        {
            NodeTag tag = (NodeTag)Enum.Parse(typeof(NodeTag), name);
            if (!Enum.IsDefined(typeof(NodeTag), tag))
            {
                throw new BadOperatorException(name);
            }
            try
            {
                Node retval = MakeBinary(tag, lhs, rhs);
                retval.Unparse();
                RegisterNode(retval);
                return retval;
            }
            catch (BadOperatorException e)
            {
                throw new BadOperatorException($"Operator {name} is not a binary operator!", e);
            }
        }

        public Node MakeIdentifierOp(String name, Node child)
        {
            NodeTag tag = (NodeTag)Enum.Parse(typeof(NodeTag), name);
            if (!Enum.IsDefined(typeof(NodeTag), tag))
            {
                throw new BadOperatorException(name);
            }
            try
            {
                Node retval = MakeUnary(tag, child);
                retval.Unparse();
                RegisterNode(retval);
                return retval;
            }
            catch (BadOperatorException e)
            {
                throw new BadOperatorException($"Operator {name} is not a unary operator!", e);
            }
        }

        // ==================================================================================
        // Error classes
        // ==================================================================================

        public class NoSetValueException : Exception
        {
            public NoSetValueException(string name) : base($"Variable \"{name}\" has no value set, cannot be evaluated!")
            {
            }
        }

        public class BadOperatorException : Exception
        {
            public BadOperatorException(string name) : base($"Operator tag \"{name}\" is not a recognized tag name!")
            {
            }

            public BadOperatorException(string message, BadOperatorException innerException) : base(message, innerException)
            {
            }
        }

        public class IncompatibleParserException : Exception
        {
            public IncompatibleParserException(Parser a, Parser b) : base ($"Parser {a} and parser {b} must be the same parser in order to compare their internal expressions.")
            {
            }
        }
    }

    // ==================================================================================
    //  Start of Node Definitions
    // ==================================================================================

    public enum NodeTag { name, literal, plus, minus, mul, div, remainder, negate, exp, sin, cos, tan, asin, acos, atan, atan2 }

    public abstract class Node {
        public NodeTag Tag { get;  }
        public Parser Tree { get; }
        public Boolean IsNegative { get; }

        protected Node(Parser tree, NodeTag tag, Boolean isNegative) { this.Tag = tag; this.Tree = tree; this.IsNegative = isNegative; }
        public abstract double Eval();
        public abstract string Unparse();

        public static Node operator +(Node lhs, Node rhs)
        {
            return lhs.Tree.m("+", lhs, rhs);
        }

        public static Node operator -(Node lhs, Node rhs)
        {
            return lhs.Tree.m("-", lhs, rhs);
        }

        public static Node operator *(Node lhs, Node rhs)
        {
            return lhs.Tree.m("*", lhs, rhs);
        }

        public static Node operator /(Node lhs, Node rhs)
        {
            return lhs.Tree.m("/", lhs, rhs);
        }

        public static Node operator ^(Node lhs, Node rhs)
        {
            return lhs.Tree.m("^", lhs, rhs);
        }

        public Node Simplify()
        {
            return SimplifyNode();
        }

        protected abstract Node SimplifyNode();

        protected string NegSign()
        {
            if (IsNegative)
            {
                return "-";
            }
            return "";
        }

        public abstract Node Negate();

        public bool Equals(Node other)
        {
            return this.Tag.Equals(other.Tag) && this.IsNegative.Equals(other.IsNegative);
        }
    }

    public class Leaf : Node
    {
        public static Regex StartZeroMatcher = new Regex("^0+");
        public static Regex EndZeroMatcher = new Regex("[0\\.]*(E\\+|E-)?0+$");

        public String Name { get; }
        public double Value { get; }

        internal Leaf(Parser tree, String name) : this(tree, name, false)
        {
        }

        internal Leaf(Parser tree, String name, Boolean isNegative) : base(tree, NodeTag.name, isNegative)
        {
            this.Name = name;
            this.Value = 0;
        }

        internal Leaf(Parser tree, double value) : this(tree, Math.Abs(value), value < 0)
        {
        }

        internal Leaf(Parser tree, double value, Boolean isNegative) : base(tree, NodeTag.literal, isNegative)
        {
            this.Name = "";
            this.Value = Math.Abs(value);
        }

        public override double Eval()
        {
            double retval = this.Value;
            if (this.Tag == NodeTag.name)
            {
                if (!Tree.VarsWithValues.Contains(this))
                {
                    throw new Parser.NoSetValueException(this.Name);
                }
                retval = Tree.VarVals[this];
            }

            // check for negative
            if (IsNegative)
            {
                return -retval;
            }
            return retval;
        }

        protected override Node SimplifyNode()
        {
            if (this.Tag == NodeTag.name)
            {
                if (Tree.VarsWithValues.Contains(this))
                {
                    double val = Tree.VarVals[this];
                    Boolean valIsNeg = IsNegative ^ (val < 0);
                    return new Leaf(Tree, Math.Abs(val), valIsNeg);
                }
            }
            else
            {
                if (Math.Abs(this.Value) < 0.0000001)
                {
                    return new Leaf(Tree, 0d, false);
                }
            }
            return this;
        }

        public override Node Negate()
        {
            if (Tag.Equals(NodeTag.name))
            {
                return new Leaf(Tree, Name, !IsNegative);
            }
            return new Leaf(Tree, Value, !IsNegative);
        }

        public override string Unparse() {
            // is a variable
            if (Tag == NodeTag.name)
            {
                return $"{base.NegSign()}{this.Name}";
            }

            // is a decimal value
            string retval = Eval().ToString("E4", CultureInfo.CurrentCulture);
            return TrimZeros(retval);
        }

        public override string ToString()
        {
            // is a variable
            if (Tag == NodeTag.name)
            {
                return this.Name;
            }

            // is a decimal value
            string retval = Eval().ToString("F9", CultureInfo.CurrentCulture);
            return TrimZeros(retval);
        }

        protected string TrimZeros(string decimalStr)
        {
            return RemoveLeadingZeros(RemoveTrailingZeros(decimalStr));
        }

        protected string RemoveTrailingZeros(string decimalStr)
        {
            decimalStr = EndZeroMatcher.Replace(decimalStr, "");
            decimalStr = (decimalStr.Length == 0) ? "0" : decimalStr;
            return decimalStr;
        }

        protected string RemoveLeadingZeros(string decimalStr)
        {
            string sign = (decimalStr[0] == '-' || decimalStr[0] == '+') ? Convert.ToString(decimalStr[0]) : "";
            decimalStr = (sign.Length > 0) ? decimalStr.Substring(1) : decimalStr;
            decimalStr = StartZeroMatcher.Replace(decimalStr, "");
            decimalStr = (decimalStr.Length == 0) ? "0" : decimalStr;
            return sign + decimalStr;
        }

        // override object.Equals
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }

            Leaf o = (Leaf)obj;
            if (!base.Equals(o))
            {
                return false;
            }

            if (this.Tag == NodeTag.name)
            {
                return this.Name.Equals(o.Name);
            }
            return Math.Abs(this.Value - o.Value) < 0.000001;
        }

        // override object.GetHashCode
        public override int GetHashCode()
        {
            return Tag.GetHashCode()
                ^ Name.GetHashCode()
                ^ Value.GetHashCode()
                ^ IsNegative.GetHashCode();
        }
    }

    public class Unary : Node {
        public Node Child { get; }

        internal Unary(Parser tree, NodeTag tag, Node child)
            : this(tree, tag, child, false)
        {
        }

        internal Unary(Parser tree, NodeTag tag, Node child, Boolean isNegative)
            : base(tree, tag, isNegative)
        {
            this.Child = child;
        }

        public override double Eval()
        {
            double childVal = this.Child.Eval();
            double retval = 0;
            switch (this.Tag)
            {
                case NodeTag.negate: retval = -childVal; break;
                case NodeTag.sin: retval = Math.Sin(childVal); break;
                case NodeTag.cos: retval = Math.Cos(childVal); break;
                case NodeTag.tan: retval = Math.Tan(childVal); break;
                case NodeTag.asin: retval = Math.Asin(childVal); break;
                case NodeTag.acos: retval = Math.Acos(childVal); break;
                case NodeTag.atan: retval = Math.Atan(childVal); break;
                default: throw new Parser.BadOperatorException(Enum.GetName(typeof(NodeTag), Tag));
            }
            retval = (IsNegative) ? -retval : retval;
            return retval;
        }

        protected override Node SimplifyNode()
        {
            // check for negation of a negative
            if (IsNegative && Tag.Equals(NodeTag.negate))
            {
                return Child.Simplify();
            }

            // simplify
            Node newChild = this.Child.Simplify();
            Node newNode = new Unary(Tree, Tag, newChild, IsNegative);
            if (newChild.Tag.Equals(NodeTag.literal))
            {
                newNode = Tree.m(newNode.Eval()).Simplify();
            }
            return newNode;
        }

        public override Node Negate()
        {
            return new Unary(Tree, Tag, Child, !IsNegative);
        }

        public override string Unparse()
        {
            return ToString(this.Child.Unparse());
        }

        public override string ToString()
        {
            return ToString(this.Child.ToString());
        }

        public string ToString(string childVal)
        {
            string op = "";
            switch (this.Tag)
            {
                case NodeTag.negate: return $"{base.NegSign()}-{childVal}";
                case NodeTag.sin: op = "sin"; break;
                case NodeTag.cos: op = "cos"; break;
                case NodeTag.tan: op = "tan"; break;
                case NodeTag.asin: op = "asin"; break;
                case NodeTag.acos: op = "acos"; break;
                case NodeTag.atan: op = "atan"; break;
                default: throw new Parser.BadOperatorException(Enum.GetName(typeof(NodeTag), Tag));
            }
            return $"{base.NegSign()}{op}({childVal})";
        }

        // override object.Equals
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }

            Unary o = (Unary)obj;
            if (!base.Equals(o))
            {
                return false;
            }
            return this.Child.Equals(o.Child);
        }

        // override object.GetHashCode
        public override int GetHashCode()
        {
            return Tag.GetHashCode()
                ^ Child.GetHashCode()
                ^ IsNegative.GetHashCode();
        }

        public static NodeTag GetTag(string op)
        {
            switch (op)
            {
                case "-": return NodeTag.negate;
                case "sin": return NodeTag.sin;
                case "cos": return NodeTag.cos;
                case "tan": return NodeTag.tan;
                case "asin": return NodeTag.asin;
                case "acos": return NodeTag.acos;
                case "atan": return NodeTag.atan;
                default: throw new Parser.BadOperatorException(op);
            }
        }
    }

    public class Binary : Node {
        public Node lhs { get; }
        public Node rhs { get; }

        internal Binary(Parser tree, NodeTag tag, Node lhs, Node rhs) : this(tree, tag, lhs, rhs, false)
        {
        }

        internal Binary(Parser tree, NodeTag tag, Node lhs, Node rhs, Boolean isNegative) : base(tree, tag, isNegative)
        {
            this.lhs = lhs; this.rhs = rhs;
        }

        public override double Eval() {
            double lVal = this.lhs.Eval();
            double rVal = this.rhs.Eval();
            double retval = 0;
            switch (this.Tag) {
                case NodeTag.div:       retval = lVal / rVal; break;
                case NodeTag.minus:     retval = lVal - rVal; break;
                case NodeTag.plus:      retval = lVal + rVal; break;
                case NodeTag.remainder: retval = lVal % rVal; break;
                case NodeTag.mul:       retval = lVal * rVal; break;
                case NodeTag.exp:       retval = Math.Pow(lVal, rVal); break;
                case NodeTag.atan2:     retval = Math.Atan2(lVal, rVal); break;
                default: throw new Parser.BadOperatorException(Enum.GetName(typeof(NodeTag), Tag));
            }
            retval = (IsNegative) ? -retval : retval;
            return retval;
        }

        protected override Node SimplifyNode()
        {
            Node newLhs = lhs.Simplify();
            Node newRhs = rhs.Simplify();
            Node newNode = null;

            // move negative signs inside
            if (IsNegative)
            {
                if (Tag.Equals(NodeTag.minus))
                {
                    return new Binary(Tree, Tag, newRhs, newLhs, false).SimplifyNode();
                }
                newLhs = newLhs.Negate();
                newRhs = newRhs.Negate();
                return new Binary(Tree, Tag, newLhs, newRhs, false).SimplifyNode();
            }

            // check for multiplication by -1
            if (Tag.Equals(NodeTag.mul))
            {
                if (IsNegativeOne(newLhs as Leaf))
                {
                    return newRhs.Negate().Simplify();
                }
                if (IsNegativeOne(newRhs as Leaf))
                {
                    return newLhs.Negate().Simplify();
                }
            }

            // simplify based on identities
            newNode = new Binary(Tree, Tag, newLhs, newRhs, IsNegative);
            if (newLhs.Tag.Equals(NodeTag.literal))
            {
                if (newRhs.Tag.Equals(NodeTag.literal))
                {
                    return Tree.m(newNode.Eval());
                }
                bool isZero = Math.Abs(((Leaf)newLhs).Value) < 0.000001;
                bool isOne = Math.Abs(1d - ((Leaf)newLhs).Value) < 0.000001;
                if (isZero && (Tag.Equals(NodeTag.plus) || (Tag.Equals(NodeTag.minus))))
                {
                    return newRhs;
                }
                if (isZero && (Tag.Equals(NodeTag.mul) || (Tag.Equals(NodeTag.div))))
                {
                    return newLhs;
                }
                if (isOne && Tag.Equals(NodeTag.mul))
                {
                    return newRhs;
                }
            }
            else if (newRhs.Tag.Equals(NodeTag.literal))
            {
                bool isZero = Math.Abs(((Leaf)newRhs).Value) < 0.000001;
                bool isOne = Math.Abs(1d - ((Leaf)newRhs).Value) < 0.000001;
                if (isZero && (Tag.Equals(NodeTag.plus) || (Tag.Equals(NodeTag.minus))))
                {
                    return newLhs;
                }
                if (isZero && Tag.Equals(NodeTag.mul))
                {
                    return newRhs;
                }
                if (isZero && Tag.Equals(NodeTag.div))
                {
                    return Tree.m(Double.NaN);
                }
                if (isOne && (Tag.Equals(NodeTag.mul)
                              || (Tag.Equals(NodeTag.remainder))
                              || (Tag.Equals(NodeTag.exp))))
                {
                    return newLhs;
                }
            }
            return newNode;
        }

        private static bool IsNegativeOne(Leaf leaf)
        {
            return leaf != null &&
                   leaf.IsNegative &&
                   leaf.Tag.Equals(NodeTag.literal) &&
                   leaf.Value.Equals(1);
        }

        public override Node Negate()
        {
            return new Binary(Tree, Tag, lhs, rhs, !IsNegative);
        }

        public override string Unparse()
        {
            return ToString(lhs.Unparse(), rhs.Unparse());
        }

        public override string ToString()
        {
            return ToString(lhs.ToString(), rhs.ToString()).Replace(" ", "");
        }

        public string ToString(string lVal, string rVal)
        {
            string op = "";
            switch (this.Tag)
            {
                case NodeTag.div: op = "/"; break;
                case NodeTag.minus: op = "-"; break;
                case NodeTag.plus: op = "+"; break;
                case NodeTag.remainder: op = "%"; break;
                case NodeTag.mul: op = "*"; break;
                case NodeTag.exp: op = "^"; break;
                case NodeTag.atan2: return $"atan2({lVal}, {rVal})";
                default: throw new Parser.BadOperatorException(Enum.GetName(typeof(NodeTag), Tag));
            }
            return $"{base.NegSign()}({lVal} {op} {rVal})";
        }

        public bool IsReflexive()
        {
            switch (this.Tag)
            {
                case NodeTag.div: return false;
                case NodeTag.minus: return false;
                case NodeTag.plus: return true;
                case NodeTag.remainder: return false;
                case NodeTag.mul: return true;
                case NodeTag.exp: return false;
                case NodeTag.atan2: return false;
                default: throw new Parser.BadOperatorException(Enum.GetName(typeof(NodeTag), Tag));
            }
        }

        // override object.Equals
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }

            Binary o = (Binary)obj;
            if (!base.Equals(o))
            {
                return false;
            }
            if (this.lhs.Equals(o.lhs) && this.rhs.Equals(o.rhs))
            {
                return true;
            }
            if (IsReflexive() && this.rhs.Equals(o.lhs) && this.rhs.Equals(o.lhs))
            {
                return true;
            }
            return false;
        }

        // override object.GetHashCode
        public override int GetHashCode()
        {
            return Tag.GetHashCode()
                ^ lhs.GetHashCode()
                ^ rhs.GetHashCode()
                ^ IsNegative.GetHashCode();
        }

        public static NodeTag GetTag(string op)
        {
            switch (op)
            {
                case "/": return NodeTag.div;
                case "-": return NodeTag.minus;
                case "+": return NodeTag.plus;
                case "%": return NodeTag.remainder;
                case "*": return NodeTag.mul;
                case "^": return NodeTag.exp;
                case "atan2": return NodeTag.atan2;
                default: throw new Parser.BadOperatorException(op);
            }
        }
    }
    // ==================================================================================
}

